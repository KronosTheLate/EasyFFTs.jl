var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EasyFFTs","category":"page"},{"location":"#EasyFFTs","page":"Home","title":"EasyFFTs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for EasyFFTs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EasyFFTs]","category":"page"},{"location":"#EasyFFTs.easyfft","page":"Home","title":"EasyFFTs.easyfft","text":"easyfft(s)\neasyfft(s, fs)\n\nKeyword arguments\n\nscalebylength::Bool: determines if the response is scaled by its length. Defaults to true.\nf::Function: an optional function to apply elementwise to the response.\n\nCompute the Discrete Fourier Transform (DFT) of the  input vector s, scaling by length(s) by default.  This function uses FFTW.rfft if s has real elements,  and FFTW.fft otherwise.\n\nIf a sampling frequency fs is supplied, the output becomes  a NamedTuple with keys freq and resp, containing the  freqiencues and response respectivly.\n\nThe optional function f allows the user to pass abs or angle  to get only the amplitude or phase of the response directly.\n\nSee also easymirror to get a symestric spectrum.\n\nExamples\n\njulia> using EasyFFTs\n\njulia> s = sin.(1:5);\n\njulia> easyfft(s)\n3-element Vector{ComplexF64}:\n  0.0587205499074596 + 0.0im\n   0.441411013590527 - 0.76819000942203im\n 0.23045453212899036 - 0.08137937206396029im\n\njulia> easyfft(s, f=abs)\n3-element Vector{Float64}:\n 0.0587205499074596\n 0.8859794430430284\n 0.24440109160213735\n\njulia> easyfft(s, 1, f=abs)\n(freq = [0.0, 0.2, 0.4], resp = [0.0587205499074596, 0.8859794430430284, 0.24440109160213735])\n\n\n\n\n\n","category":"function"},{"location":"#EasyFFTs.easymirror","page":"Home","title":"EasyFFTs.easymirror","text":"easymirror(v::AbstractVector)\neasymirror(s::NamedTuple)\n\nGiven a one-sided spectrum, return a two-sided version  by \"mirroring\" about 0. This convenience function also  ajusts the amplitude of v, or the amplitudes of s.resp apropriatly.\n\nExamples\n\njulia> easymirror(0:3)   # Mirroring the amplitudes\n7-element Vector{Float64}:\n 1.5\n 1.0\n 0.5\n 0.0\n 0.5\n 1.0\n 1.5\n\njulia> easymirror(fill(1, 4))   # Not halving the zero frequency component\n7-element Vector{Float64}:\n 0.5\n 0.5\n 0.5\n 1.0\n 0.5\n 0.5\n 0.5\n\n\njulia> nt = (freq=[0, 0.2, 0.4], resp=[1, 2, 3]);\n\njulia> easymirror(nt)\n(freq = [0.4, 0.2, 0.0, 0.2, 0.4], resp = [1.5, 1.0, 1.0, 1.0, 1.5])\n\n\n\n\n\n","category":"function"}]
}
